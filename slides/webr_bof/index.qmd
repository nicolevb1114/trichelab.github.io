---
title: "BioC2024: webR BoF"
author: "Tim Triche, Jr."
institute: "Van Andel Institute"
format: 
  revealjs:
    slide-number: true
    footer: "bit.ly/webr_bof"
    title-slide-attributes: 
      data-background-image: "QRcode.png"
      data-background-size: "20%"
      data-background-position: top
execute: 
  warning: false
filters:
- webr
webr:
  packages: ['ggplot2','ggbeeswarm','mixR','survminer','survival','table1','reshape2']
  show-startup-message: false
---


## Quarto

I use [quarto](https://quarto.org/) with 
[webR](https://webr.r-wasm.org/latest/),
usually via [quarto-webr](https://quarto-webr.thecoatlessprofessor.com/).

Below, a [germline variant analysis in pediatric leukemia](https://trichelab.github.io/webR/germline/){target="_blank"}.

```{r}
#| echo: true
#| code-fold: true
#| code-summary: "expand for full code"

combined <- read.csv(url("https://trichelab.github.io/data/combined.csv"),row=1)
combined$Source <- relevel(relevel(relevel(factor(combined$Source), 4), 4), 4)
combined$Lineage <- relevel(relevel(factor(combined$Lineage), 3), 3)
combined$Group <- paste(combined$AgeGroup, gsub("\\-", "", combined$Lineage))
combined$Group <- relevel(relevel(factor(combined$Group), 4), 4)
byGroup <- split(combined$G_PLP, combined$Group)
rs <- function(y, n, m, slop=20) {
  s <- n + (round(slop/2)) - sample(seq_len(slop), 1)
  replicate(m, sum(y[sample.int(n=length(y), size=s)] > 0) / s)
}

set.seed(1234)
library(reshape2)
res <- data.frame(lapply(byGroup, rs, n=300, m=3333, slop=20)) 
results <- melt(res, variable.name="Group", value.name="Burden")

library(mixR) 
library(ggplot2)
mixres <- select(results$Burden, ncomp=2:4)
ncomp <- mixres$ncomp[mixres$best == "*"]
fit <- mixfit(results$Burden, ncomp=ncomp)
p1 <- plot(fit, 
           title=paste("Germline P/LP variant burden across", 
                        nrow(combined), "leukemia patients"), 
           xlab="Germline burden",
           theme="minimal") + 
           scale_x_continuous(labels = scales::label_percent(), 
                              limits = c(0, 0.15))
p1
```


## webR

::: {.panel-tabset}

### webR runner

```{webr-r}
combined <- read.csv(url("https://trichelab.github.io/data/combined.csv"),row=1)
combined$Lineage <- relevel(relevel(factor(combined$Lineage), 3), 3)
combined$Group <- paste(combined$AgeGroup, gsub("\\-", "", combined$Lineage))
combined$Group <- relevel(relevel(factor(combined$Group), 4), 4)
byGroup <- split(combined$G_PLP, combined$Group)
rs <- function(y, n, m, slop=20) {
  s <- n + (round(slop/2)) - sample(seq_len(slop), 1)
  replicate(m, sum(y[sample.int(n=length(y), size=s)] > 0) / s)
}

set.seed(1234)
library(reshape2)
res <- data.frame(lapply(byGroup, rs, n=300, m=3333, slop=20)) 
results <- melt(res, variable.name="Group", value.name="Burden")

library(ggplot2)
library(ggbeeswarm)
p2 <- ggplot(results, aes(x=Group, y=Burden, color=Group)) + 
        scale_y_continuous(labels = scales::percent, limits = c(0, 0.15),
                           breaks = seq(0, .15, .025)) + 
        ylab("Germline burden") +
        geom_hline(yintercept=0.05, lty=3) + 
        geom_quasirandom() + 
        theme_classic() + 
        theme(legend.position="none", 
              axis.text.x = element_text(angle = 35, vjust = 1, hjust=1))
p2
```

### output

```{r}
#| echo: true
#| code-fold: true
#| code-summary: "expand for full code"
#| label: Supervised
#| warning: false

combined <- read.csv(url("https://trichelab.github.io/data/combined.csv"),row=1)
combined$Lineage <- relevel(relevel(factor(combined$Lineage), 3), 3)
combined$Group <- paste(combined$AgeGroup, gsub("\\-", "", combined$Lineage))
combined$Group <- relevel(relevel(factor(combined$Group), 4), 4)
byGroup <- split(combined$G_PLP, combined$Group)
rs <- function(y, n, m, slop=20) {
  s <- n + (round(slop/2)) - sample(seq_len(slop), 1)
  replicate(m, sum(y[sample.int(n=length(y), size=s)] > 0) / s)
}

set.seed(1234)
library(reshape2)
res <- data.frame(lapply(byGroup, rs, n=300, m=3333, slop=20)) 
results <- melt(res, variable.name="Group", value.name="Burden")

library(ggplot2)
library(ggbeeswarm)
p2 <- ggplot(results, aes(x=Group, y=Burden, color=Group)) + 
        scale_y_continuous(labels = scales::percent, limits = c(0, 0.15),
                           breaks = seq(0, .15, .025)) + 
        ylab("Germline burden") +
        geom_hline(yintercept=0.05, lty=3) + 
        geom_quasirandom() + 
        theme_classic() + 
        theme(legend.position="none", 
              axis.text.x = element_text(angle = 35, vjust = 1, hjust=1))
p2
```

:::


## more webR

::: {.panel-tabset}

### fit a mixture

```{webr-r}
library(mixR)
MLL <- readRDS(url("https://trichelab.github.io/data/MLL.rds"))
MLL_EVI1_fit <- mixfit(MLL$MECOM, ncomp=2)
plot(MLL_EVI1_fit, xlab="log(EVI1 transcripts)",
     title="EVI1 expression in MLL-rearranged leukemia")
```

### fit survival

```{webr-r}
library(survival)
library(survminer)
MLL <- readRDS(url("https://trichelab.github.io/data/MLL.rds"))
mixFit <- survfit(Surv(OS, OSI) ~ EVI1high, data=MLL)
ggsurvplot(mixFit, conf.int=TRUE, pval=TRUE, xlab="Overall survival (days)",
      tables.theme = theme_cleantable(), palette=c("darkgreen","darkred"))
```

:::


## webR + BioC

```{webr-r}
webr::install("GEOquery", repos=c("https://repo.r-wasm.org/","https://webr.bioconductor.org/3.18"))
library(GEOquery)
getGEOSuppFiles("GSM2545336", fetch=FALSE)
```


## htmlwidgets

Quarto also supports [htmlwidgets](htmlwidgets.org).
We think [biofabric](https://biofabric.systemsbiology.net/) particularly 
benefits from this approach:

```{r}
# devtools::install_github("timelyportfolio/RBioFabric")
library(RBioFabric)
miserables <- jsonlite::fromJSON(
  "https://rawgit.com/wjrl/D3BioFabric/master/src/data/miserablesSimple.json"
)
mis_igraph <- graph.data.frame(
  d = miserables$links
  ,vertices = data.frame(
    id = as.character( 0:(nrow(miserables$nodes)-1) ) 
    ,name = miserables$nodes
    ,stringsAsFactors = F
  )
)
bioFabric_htmlwidget( bioFabric( mis_igraph ) )
```


## more htmlwidgets

![In action](lauren_biofabric.jpg){.lightbox}



## observable.js

Observable does not like me very much.

```{ojs}
filtered = data.filter(function(penguin) {
  return bill_length_min < penguin.bill_length_mm &&
         islands.includes(penguin.island);
})
```

```{ojs}
viewof bill_length_min = Inputs.range(
  [32, 50], 
  {value: 35, step: 1, label: "Bill length (min):"}
)
viewof islands = Inputs.checkbox(
  ["Torgersen", "Biscoe", "Dream"], 
  { value: ["Torgersen", "Biscoe"], 
    label: "Islands:"
  }
)
```

```{ojs}
Plot.rectY(filtered, 
  Plot.binX(
    {y: "count"}, 
    {x: "body_mass_g", fill: "species", thresholds: 20}
  ))
  .plot({
    facet: {
      data: filtered,
      x: "sex",
      y: "species",
      marginRight: 80
    },
    marks: [
      Plot.frame(),
    ]
  }
)
```


## tidytutor

This is just plain cool. 
[tidy data tutor](https://tidydatatutor.com){target="_blank"}
It uses the datamations package.

```{=html}
<iframe width="800" height="600" src="https://microsoft.github.io/datamations/articles/Examples.html" title="Webpage example"></iframe>
```


## Challenges

* **Security**: how to ensure that we control the sandbox?
  - set up WASM hosting on lab website
  - if users pull in new data, their responsibility

* **Performance**: where is the breaking point? 
  - BioC packages are bloated; see Kana for kludges
  - Heavy lifts still require callouts 

* **Caching**: projections and foundations
  - Need to cache everything possible (e.g. NMF GSEA)
  - Need to work in compressed space if possible.

